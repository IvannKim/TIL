> ## 0217 - 0221

> ### 거침없는 자바스크립트 (None Bloking Javascript)

**Q. 현대의 자바스크립트는 무엇인가?**

#### # Javascript Pipeline

프론트 개발자로서 code, transpiler, packaging, CI, Deploy의 과정을 할 줄 알아야 한다. 앞으로 ES11(2020)에 대해 알아갈 것이다.

#### # ES5 이후 어떤 일이 일어났을까?

1. ES6

- Class, Object Literal(getter, setter)
- Arrow Function(순수한 함수만 지원하기 떄문에 가벼운 객체를 만들 수 있다)
- Iterator(제어 시스템), Generator(Iterator를 생성해주는 것), For of(앞의 것들을 편하게 사용하도록 해주는 것)
- const, let(var대신에 순차적으로 컨텍스트를 생성해주는 것)
- desructuring, rest, spread(문법상의 편의)
- Template string
- Symbol, Promise, Map, Set, WeakMap, Proxy, Reflect

2. ES7 ~ 10 (Stage3)

- 7 : 중첩된 rest 해체 `const [a, ...[b,...c]] = [1,2,3,4]`(a = 1, b = 2, c = [3,4])
- 8 : **async/await, shared memory, atomics**
- 9 : object 해체, **asynchronous iterators**(거의 모든 로직에 적용하도록 지향)(주인공)
- 10 : optional catch
- Stage3(11) : **BigInt, globalThis, ***top level await***, class field, private field**(크롬에는 이미 적용됨)/method(내부 바인딩 객체로서 종료시점 확정적), optional chaining(?.), nullish coalescing(??), WeakReference

### Program & Timing

Language code (Lint & IDE)  (문제가 생겼을때 코드를 수정하는 것이 아니라 코드가 변하는 이유를 한 가지로 규정하고 싶다라는 것이다. 변화에 대응해서 수정할 파일을 최소화 시키는 것이 목표.)
Machine language (Compile)
File
Load
Run (Runtime)
Terminate

### JavaScript Timing

ES2020, TypeScript (Lint & IDE)
Transpiler (Compile)
File & deploy
Browser load, Browser parsing (Browser compile)
Run (Runtime)
Browser close  (브라우저에서는 종료되기 전까지 자바스크립트는 종료되지 않는다.)

### State Control

꾸준한 상태 관리(메모리 관리)가 되어야한다.

변수는 메모리 주소의 별명이다. Directive Reference(직접 참조)를 사용할때는 변경되지 않도록 조심해야한다.(중간 참조 값을 변경하면 전체적인 싱크가 꺠진다.) 그래서 Indirective Reference
(간접 참조)를 사용한다. (dot notation의 쿠션을 사용한다. 런타임에서 추가적인 메모리가 연산된다.) **Linked Listsms 상태를 관리하기 위한 무기다.**

### Flow Control

명령을 관리하는 것.

#### Sync flow control
Sync flow: 메모리에 적재된 명령이 순차적으로 실행됨
Sync flow control: Goto를 통해 명령의 위치를 이동함
Sub Flow: 함수 등을 통해 별도의 명령셋을 여러번 실행함

State control을 통제한다면 Flow control을 용이하게 활용 할 수 있다.
설계의 궁극적인 목적은 State Control와 Flow Control을 한 군데에서 하는 것이다.(코드를 어디에 배치 할 것인가?) 제어의 역전은 각각의 특별한 상황에 따라 제어 하지 않고 제어포인트를 하나만 두고 제어하는 것이다.