> ## 0318

### 쿠키와 세션을 사용하는 이유

- HTTP 프로토콜의 특징
  Connenctionless
  클라이언트와 서버가 요청과 응답을 한 번 주고받으면 연결을 끊어버리는 특징을 말한다.
  클라이언트가 request를 서버로 보내면 서버는 클라이언트가 보낸 request에 맞게 response를 보내고 연결을 끊는다.

- Stateless
  위처럼 요청과 응답으로 인해 통신이 끝난다면 상태 정보를 유지하지 않는 특징이다.
  예를들어 메인페이지에서 로그인을 하고 다른 페이지로 넘어가면 다시 로그인을 해야된다.

이런 특징들 때문에 쿠키와 세션 혹은 jwt를 이용하여 사용자 인증에 대한 정보를 유지할 수 있다.

> ## 0319

### 객체지향 5원칙(SOLID)

객체지향에서 꼭 지켜야 할 5개의 원칙을 말한다. 일단 한번 보면 개념은 알아 듣긴 하지만 막상 실현하려면 생각보다 어려움이 따른다. 이 5개의 원칙의 앞글자를 따서 SOLID라고도 부른다.

#### 1) SRP : 단일 책임 원칙 (Single Responsibility Principle)

객체는 오직 하나의 책임을 가져야 한다. (객체는 오직 하나의 변경의 이유만을 가져야 한다.)

사칙연산 함수를 가지고 있는 계산 클래스가 있다고 치자. 이 상태의 계산 클래스는 오직 사칙연산 기능만을 책임진다. 만일 프로그램이 대대적으로 공사를 들어가게 되더라도 계산 클래스가 수정될만한 사유는 누가 봐도 사칙연산 함수와 관련 된 문제 뿐이다. 이처럼 단일 책임 원칙은 클래스의 목적을 명확히 함으로써 구조가 난잡해지거나 수정 사항이 불필요하게 넓게 퍼지는 것을 예방하고 기능을 명확히 분리할 수 있게 한다.

위의 원칙이 제대로 지켜지지 않으면 어떻게 될까? 어떤 프로그래머가 위의 계산 클래스를 통해 GUI를 가지는 계산기 프로그램을 개발하고 있다. 그런데 중간에 귀찮다고 GUI 관련 코드를 계산 클래스에 넣어버렸다. 이렇게 되면 계산 클래스는 계산과 GUI라는 두 가지 책임을 지게 되는데 만일 GUI 관련 수정 사항이 발생하게 되면 별 상관도 없어보이는 계산 클래스를 고치게 된다. 이처럼 하나의 클래스가 두 가지 이상의 책임을 지니게 되면 클래스의 목적이 모호해지고 기능을 수정할 때 영향을 받는 범위도 커져서 유지보수가 힘들어지며, 결국 작성한 본인조차도 이게 정확히 뭐하는 클래스인지 명확히 설명할 수가 없는 스파게티 코드가 되어버린다.