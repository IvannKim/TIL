> ## 0217 - 0222

> ### 거침없는 자바스크립트 (None Bloking Javascript)

**Q. 현대의 자바스크립트는 무엇인가?**

> #### Javascript Pipeline

프론트 개발자로서 code, transpiler, packaging, CI, Deploy의 과정을 할 줄 알아야 한다. 앞으로 ES11(2020)에 대해 알아갈 것이다.

> ####  ES5 이후 어떤 일이 일어났을까?

1. ES6

- Class, Object Literal(getter, setter)
- Arrow Function(순수한 함수만 지원하기 떄문에 가벼운 객체를 만들 수 있다)
- Iterator(제어 시스템), Generator(Iterator를 생성해주는 것), For of(앞의 것들을 편하게 사용하도록 해주는 것)
- const, let(var대신에 순차적으로 컨텍스트를 생성해주는 것)
- desructuring, rest, spread(문법상의 편의)
- Template string
- Symbol, Promise, Map, Set, WeakMap, Proxy, Reflect

2. ES7 ~ 10 (Stage3)

- 7 : 중첩된 rest 해체 `const [a, ...[b,...c]] = [1,2,3,4]`(a = 1, b = 2, c = [3,4])
- 8 : **async/await, shared memory, atomics**
- 9 : object 해체, **asynchronous iterators**(거의 모든 로직에 적용하도록 지향)(주인공)
- 10 : optional catch
- Stage3(11) : **BigInt, globalThis, ***top level await***, class field, private field**(크롬에는 이미 적용됨)/method(내부 바인딩 객체로서 종료시점 확정적), optional chaining(?.), nullish coalescing(??), WeakReference

> ### Program & Timing

Language code (Lint & IDE)  (문제가 생겼을때 코드를 수정하는 것이 아니라 코드가 변하는 이유를 한 가지로 규정하고 싶다라는 것이다. 변화에 대응해서 수정할 파일을 최소화 시키는 것이 목표.)
Machine language (Compile)
File
Load
Run (Runtime)
Terminate

> ### JavaScript Timing

ES2020, TypeScript (Lint & IDE)
Transpiler (Compile)
File & deploy
Browser load, Browser parsing (Browser compile)
Run (Runtime)
Browser close  (브라우저에서는 종료되기 전까지 자바스크립트는 종료되지 않는다.)

> ### State Control

꾸준한 상태 관리(메모리 관리)가 되어야한다.

변수는 메모리 주소의 별명이다. Directive Reference(직접 참조)를 사용할때는 변경되지 않도록 조심해야한다.(중간 참조 값을 변경하면 전체적인 싱크가 꺠진다.) 그래서 Indirective Reference
(간접 참조)를 사용한다. (dot notation의 쿠션을 사용한다. 런타임에서 추가적인 메모리가 연산된다.) **Linked Listsms 상태를 관리하기 위한 무기다.**

> ### Flow Control

명령을 관리하는 것.

> #### Sync flow control

Sync flow: 메모리에 적재된 명령이 순차적으로 실행됨
Sync flow control: Goto를 통해 명령의 위치를 이동함
Sub Flow: 함수 등을 통해 별도의 명령셋을 여러번 실행함

State control을 통제한다면 Flow control을 용이하게 활용 할 수 있다.
설계의 궁극적인 목적은 State Control와 Flow Control을 한 군데에서 하는 것이다.(코드를 어디에 배치 할 것인가?) 제어의 역전은 각각의 특별한 상황에 따라 제어 하지 않고 제어포인트를 하나만 두고 제어하는 것이다.

> #### Blocking

Sync Flow가 실행되는 동안 다른 일을 할 수 없는 현상
Blocking은 명령을 메모리에 적재하고 순차적으로 진행하기때문에 무조건 존재한다. 그렇다면 개발자가 할 수 있는 것은 **Blocking을 줄이는 것**이다.

- sync flow를 짧게 하기
- 다른 쓰레드에 sync flow를 떠넘기기 : 다른 쓰레드의 작업이 완료 되면 원래 쓰레드에 보고해야함(이벤트 루프가 기다리고 있다.)

=> 메인 쓰레드는 줄이고 다른 쓰레드로 위임하는 것이 좋다.

***Non Blocking : Sync Flow가 납득할 만한 시간 내에 종료되는 것***

> #### Sync & Async

- Sync - 서브루틴이 즉시 값을 반환 함(순서가 정확)
- Async - 서브루틴이 다른 수단으로 값을 반환 함 (역으로 즉시 반환하지 않는다면 모두 Async다.)

다른 수단? Promise, callback function, iterations(비동기형도 존재한다.)

> #### Async의 단점

- 호출결과가 즉시 반환되지 않으므로 현재의 sync flow가 종료 됨
- 그 결과, 현재의 어휘공간 내의 상태를 결과 시점에 사용할 수 없음
- 요청 시의 상태를 별도로 결과 시점에 전달할 부가장치 필요

> #### Sync의 장점 + Async의 장점

- sync 로직으로 async를 사용할 수 있게 함
- 하지만 sync flow가 어긋나므로 이전 sync flow의 상태를 기억하여 이어줄 장치 필요
- 상태를 기억하고 이어주는 장치 - Continuation
- 이를 활용하는 프로그래밍스타일 - **C**ontinuation **P**assing **S**tyle(중요)

***=> Async/await, Generator, Async iterator를 CPS 스타일로 코딩을 하고 메인 쓰레드의 부하를 줄이고 어떻게 하면 블록킹 구간을 줄일지에 대해 알아갈 것이다.***
