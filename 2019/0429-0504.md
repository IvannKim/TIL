# 0429

- 프로토타입

: 자바스크립트는 프로그래밍 언어의 기존 C++이나 자바와 같은 객체지향 프로그래밍 언어와는 다른 **프로토타입 기반의 객체지향 프로그래밍**을 지원한다. 따라서 JS의 동작 과정을 제대로 이해하려면 프로토 타입의 개념도 잘 이해해야한다. 

 자바와 같은 객체지향 프로그래밍에서는 클래스를 정의하고 이를 통해 객체를 생성하지만, JS에서는 이러한 클래스 개념이 없다. 대신 객체 리터럴이나 생성자 함수로 객체를 생성할 수 있다. 이렇게 생성된 객체의 부모객체가 ***프로토타입*** 객체다. 상속개념과 마찬가지로 자식 객체는 부모객체가 가진 프로퍼티 접근이나 메서드를 상속받아 호출하는 것이 가능하다. 

 JS에서 모든 객체는 자신을 생성한 생성자 함수의 **prototype 프로퍼티**가가리키는 **프로토타입객체**를 자신의 부모 객체로 설정하는 **[[Prototype]] 링크**로 연결 한다.

 결국, 객체를 생성하는 것은 생성자 함수의 역할이지만, 생성된 객체의 실제 부모역할을 하는 것은 생성자 자신이 아닌 prototype 프로퍼티가 가리키는 프로토타입 객체다.

# 0430

## Object
```js
var obj = {
	name: 'kamake'
};
```
객체 내의 value(값)에는 자바스크립트에 존재하는 어떤 것이 들어와도 가능하다.
키값은 문자열로도 표기 가능하다. 왜냐면 결국 내부적으로 string으로 입력되기 때문이다.  자바스크립트에서 객체 내부적으로는 key값을 String으로 변환해서 인식하고 처리한다. 그렇기 때문에 그 키값을 필요에 의해 찾는 다면, 이해하고 찾아야 한다.

<B>객체의 키(속성, 프로퍼티), 벨유를 반복문을 하고싶다면 </B>

- for... in
  : 객체의 키값에는 순서가 정해져 있다고 장담할 수 없다. 임의대로 반복을 한다.

```js
var a = {
	name: 'kamake',
	age: 28
};

for(var prop in a) {
 console.log(prop);  // key 값을 가져올 수 있음음음음
 console.log(a[prop]); //value 값도 가져올 수 있음
}
```
```js
var kamake = 123;
var a = 'firstName';

var obj = {
	a: kamake; // 'firstName': 123
};

console.log(obj[''+'a'+''+'']) // 123 (결국 []에 남는 값이 키값과 같으면 된다.)
```

###+)
- 구조를 예쁘게 잘 짜는 것이 능력이다. => 자료구조 공부



## Array
 배열은 객체의 하위호환이라 생각하면 된다. 배열도 객체이기 때문에 어떤 타입의 값이 지정되어도 상관 없다.

- `unshift( )`, `pop( )` 는 배열의 앞, 뒤의 요소를 제거하고, 제거된 요소를 반환한다. 단, 빈 배열일 경우 `undefined`를 반환한다.
- `shift(z)`, `push(z)` 는 배열의 가장 앞, 뒤에 새로운 요소 `z`를 추가하고, 배열의 새로운 길이를 반환한다.



###+)
- JS에서 배열은 객체지만 순서가 있다. (index)
- 객체와 같이 요소는 무엇이든지 가능
- 문자열은 이미 저장된 상태이므로 할당된 값 자체를 직접 변경시킬 수 없다. (값을 활용해서 분해시켜서 중간중간 요소나 전체 정보를 변경시킬 수 있다.)
- 메소드를 공부 할때 중요한 것은 **디테일하게** 무엇이 매개변수가 되고 반환되는지 알아야 한다. 기본적인 "설명"부터 읽고 이해해야 한다. "기본예제"를 파악해야한다. "구문"항목도 기억해야한다. 




## Primitive vs Reference
모든 값은 그 성격에 따라 구분 할 수 있다.
### 1) Primitive(원시적인)
#### - Type
- Boolean
- Number
- String
- Null
- Undefined
```shell
Q. 할당되어 있지 않는 값을 찾게 되면 null이 아니라 undefined로 표현되는 것일까?
(값이 없는 것이라면 undefined가 아닌 아무 값조차 없는 null이 어울리지 않을까?)
A. undefined 라고 표현하기로 약속된 것이기 때문이다. 
```
변수에 Primitive 값을 할당하고 값을 비교할때, 같은 값이면 같다라고 치부하는 것이다. 
변수에 이미 할당된 값을 새로운 값으로 할당 한다면 전에 존재했던 값은 재활용하지 못한다. ( 값에 할당된 메모리 주소를 재활용하지 않고 새롭게 메모리 주소를 링크해서 그 값을 변수에 할당 해준다. )


### 2) Reference

 값의 생김새(타입, 값)가 같아 보여도 참조하고 있는 위치가 다르다면 같은 값이라 보기 어렵다. JS는 **객체를 *생성하면* 새로운 장소에 저장**한다. 위치는 항상 다를 수 박에 없는 성질이 있다. 특수한 객체인 배열과 함수 모두 객체에 포함되기 때문에 저장된 위치를 꼼꼼히 신경 써야 한다. 

- 변수에 참조된 주소는 같지만 할당된 정보는 다르다.
- 위치를 기준으로 비교를 하게 된다. 
- 변수에 할당할 객체를 새롭게 생성한다면 객체의 위치를 변수에 저장 시켜놓는다.

객체를 비교해서 위치를 신경써야하는 것이 아니라 변수를 비교할 때는 어디에 담겨있는지와는 상관없이 그 변수만을 판단하면 된다.



## +)

- 내가 사용할 수 있는 재료들에 대해 공부하는 것.  얼마나 잘 조합할 수 있는지, 마치 전쟁터에서 군인들을 적재적소에 배치해서 뛰어난 용병술을 가지는 것이 중요하다.
- 개념들을 알고 지나가는 것이 아니라 **직접 사용해보면서 인지하고 기억하기!** 
- 꼼꼼히 읽으면서 공부 & 작업하기
- 문서(article)에서 영단어를 만나면 의미를 먼저 파악해라.

# 0501

- `this`를 파악할때 네 가지 방식을 잘 기억해서 써먹자

  1) 함수 호출, 2) 메소드 호출, 3) 생성자 함수, 4)  apply / call / bind 호출

  함수의 기본 메소드인 `call()`, `apply()`는 함수 호출할 때, `bind()`는 함수를 선언하는 단계일 때 쓴다.

- 학업 스케줄을 할 수 있는 것보다 조금 높게 계획해서 성취감을 느낄 수 있게 하기

- 열심히 좀 해봅시다ㅏ...허허

# 0502
## 1) Scope
어떤 변수들의 접근성을 결정하는 것
### (1) function scope
**- var**
내부에서 외부는 접근 가능
외부에서 내부는 접근 불가능
```js
var a = 1;
function foo() {
	var b = 2;
	function foo() {
	console.log(b);	// 2
	}
	console.log(a);	// 1
	console.log(b);	// 2
}
foo();
console.log(b);	// undefined
```
콘솔을 스코프를 따라 타고 올라가서 가장 가까이에 있는 확인하려는 변수를 체크한다. 스코프 내에 부재할 시 해당 스코프를 감싸는 상위 스코프에서 찾는다.

### (2) IIFE
즉시 실행 함수 (Immediately Invoked Function Expression)
임의로 함수를 만들어서 정확한 **범위가 지정**되게 만든다. 
외부에서 함수 내부의 변수를 접근하지 못하도록 감싸고 막는 느낌.

### (3) Global Scope
글로벌 스코프는 항상 존재한다. 최상단의 범위로 단 하나의 형태로 존재한다.
특수한 환경이 아닌 이상 일반적인 상황에서는 자제하는 것이 좋다. 글로벌스코프는 개발자들이 최대한 쓰니 않으려 한다. 그래서 즉시 실행함수를 만들어 쓴다.
### +)
- 스코프라는 것은 기본적으로 해당하는 스코프에서 최대한 찾다가 찾을때까지 상위 스코프로 타고 올라가다 결국 글로벌 스코프까지 도달한다.
- 스코프의 성격을 알고 프로그래밍 작업을 해야한다.

## 2) Hoist
보통 끌어올리는 장비를 호이스트라고 일컫는다.
```js
console.log(a); // undefined

var a = 1;

console.log(a); // 1
```
첫번째 콘솔로그에서 3번째줄에 있는 변수 선언을 hoist한다.(속해있는 스코프내에서 끌어올린다.)

자바스크립트를 실행할때, 호이스팅이 가장 먼저 작동된다.

### Function Declaration
함수 선언식으로써 함수 자체가 호이스팅 된다.(?)

### Function Expression

```js
d(); // undefined

var d = function () {
	console.log('I am inside function d');
};

d(); // 'I am inside function d'
```

지금과 같은 함수표현식 예제에서는 첫번째 함수호출에서는 함수가 호이스팅이 되지 않고 할당되지 않은 `var d`가 호이스팅되고 `undefined`로 에러가 된다.

 ### +)
- Function Declaration VS Function Expression
:  취향에 따라, 회사에 따라 한 가지를 정해서 통일성있게 쓰도록 해야한다.
-  Code Style
: [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript)를 많이 따르는 추세다.
- 함수 내에서 return문은 개행(줄바꿈) 시키면줄 문장이  끝난 것이다.








