# 0715 - 0716
## Sorting Applications Part - 1
#### where sorting algorithms help us
- Sorting a list of people
- Find the median(중간 값)
- Find duplicates in some data
- Binary Search in a Database

#### Why do we study sorting algorithms?
- Need guaranteed performance? 
: 시스템 정렬을 쓰면 될텐데, 그럼에도 불구하고 정렬 알고리즘을 사용할 수 있어야 할까?
- Large records? & Small records?
: (데이터의 양에) 상황에 따라 알고리즘의 로직이 달라질 수 있다.
- Stable?
:제한사항에 맞는 성능적인 보장이 필요한 경우에 맞춰서 사용해야한다.

**차이를 이해하고 비교할 수 있어야한다.**

### Bubble Sort
정렬하는 방식이 버블처럼(?) 점진적으로 자신의 위치를 찾아간다는 것.

#### How it works
- Perform a sequence of passes through the list.
- On each pass: proceed from left to right, swapping adjacent elements if they are out of order.
- Larger elements bubbles up to the end of the list.
- At the end of the kth pass, the k rightmost elements are in their final positions.
정렬해야하는 대상이 있는 경우
반복적으로 전체를 순회할 경우 바로 옆에 있는 요소와 비교한다.
한번의 순회를 할때마다 하나의 요소들이 제 위치를 찾아가는 방식이다.

#### Big-O
worst case : O(n^2) When does it have worst case perfomence?
best case :  O(n) When does it have worst case perfomence?

#### Disadvantages
성능적으로 떨어진다.
자료가 많아질 수록 빅오의 최악의 상황이 더욱 심화 된다.

#### Advantages
- Memory : **"in place"**(자료안에서 제한적인 상황) 주어진 자료 이외에 추가사항이 없는 데이터
- Easy to write
- Good for testing whether a list is sorted or not : 리스트가 정렬이 돼있는지 아닌지 테스트할 경우

### Insertion Sort
왼 -> 오 진행, 제 자리에 푸쉬해주도록. 버블 정렬과 비슷한 방식이다. 다른 점은 왼쪽 요소와 비교한다.

####  Big-O
worst case : O(n^2)
best case :  O(n)
(버블 정렬과 거의 동일)

#### Disadvantages
성능적으로 좋지 않다. (구리다) 그러나 기본적으로 알아야한다.

#### Advantages
- Memory : **"in place"**(자료안에서 제한적인 상황) 주어진 자료 이외에 추가사항이 없는 데이터
- Easy to write 
- Good for testing whether a list is sorted or not : 리스트이 정렬이 돼있는지 아닌지 테스트할 경우
(버블과 거의 동일)

기본적으로 알아야할 정렬 두 가지이다.

## Sorting Applications Part - 2
### What does "Stable" mean?
원본 데이터의 두 요소의 **상대적인 위치**가 최종 결과에서도 유지되는가에 따라 stable과 unstable이 결정된다. 상황에 따라 기존의 정보 위치를 유지해야할 경우 있다.
결과적으로 stable한 값을 구해야하는데, 시스템 솔트가 unstable하게 도출한다면 어울리지 않는 기술을 쓰는 것이다.

### What does "in place" mean?
Sorts the input without requiring additional space
주어진 데이터 내에서 사용하면 되는 것인지 아닌지에 따라 구분된다.
[Reference link](https://www.quora.com/What-do-you-mean-by-in-place-and-stable-sorting-techniques)

### +)
- 성능은 좋지만 나의 상황에 어울리지 않는 다면 비효율적인 것이다.
- text로 정리 하면서 생각정리도 된다.
- 누군가에세 코드 로직을 설명할떄는 큼직한 로직들로 설명해야한다,.

### Selection Sort
왼 -> 오
선택해서 정렬하는 방식
인덱스에 있어야하는 요소를 찾아서 바꿔 정렬하는 방법
인설션과 비슷하지만 절대적인 인덱스 기준으로 진행된다.

####  Big-O
worst case : O(n^2)
best case :  O(n^2) 자리를 기준으로 정렬하기 때문에 더 나아질 수 있는 자료는 없다.

#### disadvantages
성능적으로 거의 최악인다. (완전 구려)

#### Advantages
- Memory : "in place"기존 데이터에서 인덱스만 교환한다. 추가 공간의 필요성이 없기 떄문이다.
- Easy to write
##### Is selection sort stable? 
**unstable**.

### Merge Sort
It is based on the process of merging two sorted arrays into a single sorted array.
병합 정렬.
정렬된 두 배열을 하나의 정렬된 배열로 만드는 방법.

#### Big-O
worst case, best case: O(n log n) logn으로 진행이 되는데 n개로 되기때문

#### disadvantages
in place가 아니다. => 공간적인 필요가 많다. O(n) space.
n log n은  n^2보다 (항상) 빠르다.

#### Advantages
- Best case, Worst case: All O(n log n)
다른 정렬의 성능보다 낫다. 베스트나 월스트의 빅오가 같다. 
꾸준히 잘하는 선수. (상황에 맞게 쓰면된다.)
[Reference link](https://www.quora.com/What-are-the-pros-and-cons-of-merge-sort)

#### Divide and Conquer
Divide :  Split the array in half, forming two subarrays.
최대한 작은 모양으로 쪼갠다.
Conquer : Apply merge sort recursively to the subarrays, stopping when a subarray has a single element.
정렬을 재귀적으로 해결하는 것.
(이러한 카테고리를 알고 있으면 좋다.)

[Reference link](https://www.geeksforgeeks.org/divide-and-conquer-algorithm-introduction/)

### +)
- 문제 해결하기 전에 구조에 대해 생각을 먼저해보기

**Q. stable?**
Insertion Sort, Merge Sort, Bubble Sort
**Q. in place?**
Insertion Sort, Bubble Sort, Selection Sort

#### TODO
- Quick Sort
- Divide and Conquer
- Dynamic Programming