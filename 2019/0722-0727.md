# 0722 - 0723

- 씽글쓰레드
한번에 한가지 일만 한다.

- v8 엔진
: 힙(저장 공간), 스택

- call stack
: 쌓이고 빠지고 를 반복
콜스택에는 함수 실행만 들어간다.
쌓인다는 것은 메모리 공간을 차지 하는 것이다. 브라우저의 메모리 공간의 제한이 있기때문에 에러메세지가 뜬다.(실제로 무한한 사이즈가 아니어도 브라우저의 사이즈를 넘는다면 제한할 수 있다.)

- Web API
: 엔진에 속한것이 아니다. (js에 속한 것이 아니다.)
여기서 시간을 재고 콜백큐로 밀어넣는다.

- callback queue
: 기본적으로 큐는 줄서는 것. 즉, 콜백이 줄서는 것이다. 

- 비동기
setTimeout =  정확한 시간을 뜻한다기 보다 ~이후에 실행이 된다는 것을 명시한다. 실제 시간을 재기 시작하는 타이밍은 웹api로 넘어오자 마자이다.
여러개의 셋타임아웃의 순서가 늦더라도 시간이 더짧다면 콜백큐로 줄을 먼저 세운다. 

-> 공통점은 이벤트 루프와 연관성이 있다.

#### Run To Completion
한번 실행되면 끝까지 실행된다. 
콜스택에 쌓여있는 것들이 모두 사라져야 콜백큐에 쌓였던 것들이 순차적으로 실행된다.
이러한 과정 중 콜스택이 비어있는지 확인하고 콜백큐의 내역을 보내주는 역할을 하는 것이 이벤트 루프이다.

실행이 종료되어야 다른 것들이 연산이 된다. 
이벤트루프는 비동기적인 것만 실행하고 담당하는 것이 아니라 다양하게 종합적으로 관장한다.
실제로 요청을 보내는 것은 Web API, 응답이 오면 화면에 업데이트해야할 내용과 등등의 것들을 줄세우는 작업을 한다. 

#### Render Queue
화면에 랜더되는 내용들을 줄세운다.
랜더 트리에는 헤드가 속하지 않는다. 실제로 화면에 보여줘야할 것들만 트리구조로 형성한다.

[rendertree](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png)

이벤트 루프가 큐(job queue, callback queue, render queue)들을 확인하면서 차례로 줄세워준다.
코드상으로 나열된 내역들을 브라우저가 참고해서 랜더큐로 정보를 줄세운다.
돔이나 cssom이 변경되었을 경우에는 랜더트리를 새로 구성한다.(실제적으로는 그렇지 않을 것이지만 브라우저 내부의 로직대로 움직인다.) 
돔 -> 레이아웃 -> 페인트


### Git
버전 컨트롤 시스템
원시적인 일은 변경사항을 기억하는 것이다.
파일 변경사항을 추적해주는 프로그램
협력개발을 도와주는 프로그램
다양한 파일들을 공유하고 조율하고 협업하는 프로그램
linus benedict torvalds
- 버전 컨트롤
사용자가 코드와 그 코드의 히스토리를 사용자 컴퓨터에 보관함
인터넷 접근이 필요없음

- 스냅샷
코드 히스토리를 기억하는 방식
주어진 시점에 어떻게 생겼는지 기록한다.
시점은 선택해서 명령한다.
기록된 시점으로 볼 수 있다.

- 커밋
스냅샷을 생성하는 행위
동사, 명사로 이루어진다.
기본적으로

3가지
1) 파일 변경 사항
2) 바로 이전 커밋, 즉 "parent commit"
3) 커밋 해쉬 (고유한 값을 지닌다.)

- 리포지토리
모든 파일들과 그 파일들의 히스토리가 모여있는 곳
개인 컴퓨터나 클라우드 서버에 있다.
클라우드에서 복사해서 다운 받는 행위는 클론
클론함으로서 협업이 가능해진다.
내 컴퓨터에 없는 내용을 클라우드로부터 추가적으로 다운로드 받는 행위를 풀이라고 한다. (유사 : 패치)
패치 : 클라우드와 내 컴퓨터의 변경사항의 차이점을 다운만 받는것이고 실제로 바뀐것이 아니므로 헤드가 바뀌지 않는다. / 머지 오리진/마스터는 브랜치에까지 다운

- 브랜치
모든 커밋들은 브랜치내에 존재한다.
브랜치는 아주 많이 있을 수 있다.
깃에서 항상 메인되는 브랜치는 **마스터** 브랜치이다.


보통 하나의 프로젝트는 하나의 리포, 여러개의 브랜치, 가가의 브랜치 속에는 커밋들이 있을 것이다.

- 헤드
현재 브랜치의 가장 마지막 커밋을 보통 지칭한다.

- 마스터
모든 프로젝트의 메인 브랜치

- 커밋만들기
파일 변경사항을 기록하고싶을때 변경사항을 스테이지에 올린다.
스테이지에 올린다는 것은 우리가 수정한 파일 내역 중에 다음 커밋에 포함하고 싶은 사항을 예약하는 것
스테이지에 올라가 있는 것만 커밋된다.

- 깃로그
커밋 히스토리를 최신 순으로 보여준다.

- 깃허브
깃들의 허브
깃 레포지토리 호스팅 서비스 업체
버전관리하기 위해, 백업을 위해, 협업을 위해

- 깃허브 연결하기
깃 리모트 -v 
깃 리모트 에드
ex) 깃 리모트 에드 오리진 url
오리진 이라고 이름 짓는다.
// 리모트 브랜치에 반영하기
깃 푸쉬 오리진 마스터

# 0724

### 디자인 패턴
프레임 워크, 라이브러리 vs 디자인 패턴 등과 같은 것들은 도구일뿐이다.

### +)
- **그저 영혼 없이 도구를 쓰는 것보다는 이해하고 쓰는 사람이 된다는 것**
- 문제를 해결하기 위한 원리를 근본적으로 이해하는 것은 중요하다. 그래야 응용할 수가 있다. 

#### 장점
- 검증 
다수의 사람들이 유사한 방법으로 사용했기때문에 검증이 된것이다.
- 재사용성
유사한방법으로 사용했다는 것은 다양하게 적용할 수 있다는 것이다. (이미 준비된 재료와 같은 것)
- 표현이 가능함
어떠한 패턴을 적용했을 경우 의미를 유추해서 파악하기 쉽다. (가독성이 높다는 뜻이다.)
정확한 해결책은 아니다. (어느정도의 대략적인 설계도)

프로그래밍은 답이 없고 각각의 장단점이 있는 것이다.

### 객체 생성 패턴
#### 1. 모듈
하나의 조각(like 레고블럭), 

#### 1-1 객체 리터럴
```js
let module = {
  etc: ,
  fn: function () {

  }
}

```
상황에 따라서 객체를 보호해야할 경우가 생긴다.
#### 1-2 정보 보호
함수스코프로 변수를 보호하고 변수를 조정하는 객체 리턴해주면서 보호한다.
브라우저환경은 사용자에게 직접적으로 보여지기때문에  보안적으로 취약할 수 밖에 없다. 그렇기때문에 신경써서 코딩해야한다.
글로벌에 변수를 쓰는 것을 지양하는 것이 좋다. 네임스페이스 패턴을 사용하는 이유는 많은 함수, 객체, 변수들로 전역으로 되어 선언되어 있는 것을 줄이고자 하는데 큰 목적이 있다. 

#### 팩토리 함수
도 글로벌에 속하기 떄문에 마저도 즉시실행함수로 감싸서 사용한다면 보호가 된다.
또하나의 패턴이다. 

#### Mixin
팩토리함수를 재사용하면서 공동으로 쓰는 것들이 많아질 경우. 어떠한 경우를 공유한다는 것.
큰 변화없이 **확장**이 가능한 패턴 (심플) / 코드를 재활용시켜주는 것

#### 1-3 싱글튼
객체는 참조함으로써 이뤄지는데, **단!** 하나의 객체만 생성한다는 것.

#### 코드 재사용 패턴
프로토타입 패턴

#### 체이닝

#### pub-sub
퍼블리쉬 앤 섭스크라입

## Promise

라이브러리를 사용하지 않을때 비동기적으로 코딩을 할때 가장 흔하게 사용할 수 있는 방법이다. 왜냐하면 JS에서는 함수가 일급객체이기 때문이다.

#### continuation passing style
함수를 지속적으로 넘겨 주는 것
단점은 콜백지옥에 빠질 수 있다.

`new Promise(fn)`=> 인스턴스 **객체가 반환**된다. (활용 범위가 커졌다는 것)
비동기처리를 할 수 있는 것이 도출. 
사용할 수 있는 물건이 손에 잡혔다는 것이다. 
비동기처리를 객체지향적으로 다루는 것이 가능토록 하는 것이다.
(프로미스는 콜백헬을 완벽하게 해결하는 것이 아니다. 프로미스를 써도 콜백헬이 발생할수도 있다. )

함수를 인자로 하나 받는다. 인자는 바로 호출된다. 그 함수의 인자는 리졸브와 리젝트로 받는다.
리졸브 (좋은 것)
리젝트 (나쁜 것)

인스턴스의 메소드에는
덴(함수) : 리졸브(인자로 들어간 함수가 댄의 인자로 간다)가 모두 됐을때 호출
모두 실행되고 댄이 실행된다는 것은 리졸브 과정중에 실패한 것이 없다는 인증이 됐다는 것이다.
캐치(함수) : 리젝트됐을때 호출

프롸미스는 객체지향프로그래밍에 확장성을 부여했다.