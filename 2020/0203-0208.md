> ## 0203

> ### Redux

(Redux 가 뭔가요?)
Redux 는 Flux 설계 패턴을 기반으로한 Javascript App 을 위한 예측 가능한 상태 컨테이너입니다. Redux 는 React 또는 다른 view 라이브러리들과 함께 사용될 수 있습니다. 그것은 작고 (2KB 정도) 종속성이 없습니다.

Redux 는 세가지의 기본원리를 따릅니다.

단일 출처: 전체 application 의 상태는 하나의 스토어의 객체 트리에 저장됩니다. 단일 상태 트리를 이용하면 시간 경과에 따른 변경사항 추척과 디버깅 또는 application 의 검사를 쉽게해줍니다.

읽기전용의 상태: 상태를 변경하는 유일한 방법은 발생한 일에 대한 액션을 보내는것입니다. 이것은 view 와 Network callback 에서 상태를 직접 쓰지 않도록 보장합니다.

순수함수로 만들어진다: 상태 트리가 액션에 의해 어떻게 변환될지를 reducers 에 작성해야합니다. Reducers 는 이전의 상태와 매개변수를 받는 순수함수이고 다음 상태를 반환해줍니다.

> ## 0204

> ### 브라우저 실행

1. HTML 마크업을 처리하고 DOM 트리를 빌드한다. ("무엇을" 그릴지 결정한다.)
2. CSS 마크업을 처리하고 CSSOM 트리를 빌드한다. ("어떻게" 그릴지 결정한다.)
3. DOM 및 CSSOM 을 결합하여 렌더링 트리를 형성한다. ("화면에 그려질 것만" 결정)
4. 렌더링 트리에서 레이아웃을 실행하여 각 노드의 기하학적 형태를 계산한다. ("Box-Model" 을 생성한다.)
5. 개별 노드를 화면에 페인트한다.(or 래스터화)

브라우저는 HTML의 구조(DOM)와 CSS의 구조(CSSOM)의 분석이 끝나야 웹페이지를 그릴 수 있는데 자바스크립트가 어떻게 관여할지 모르기 때문에 로딩이 끝나길 기다리게 됩니다. 그 말은 곧 자바스크립트의 용량을 줄여 빠르게 불러올수록 웹페이지를 그리는 시점이 빨라진다는 것을 뜻합니다.

> ## 0205

> ### 화살표 함수와 일반 함수의 차이

화살표 함수는 this와 arguments를 바인딩하지 않는다. 그 대신, 일반적인 this와 arguments와 동일한 범위를 가지고 있다.

화살표 함수는 new로 호출할수 없다.

화살표 함수는 항상 익명이며, 자신의 this, arguments, super 그리고 new.target을 바인딩하지 않는다. 그래서 생성자로는 사용할 수 없다.

> ## 0206

> ### 동기와 비동기의 차이

비유를 통한 쉬운 설명
해야할 일(task)가 빨래, 설거지, 청소 세 가지가 있다고 가정한다. 이 일들을 동기적으로 처리한다면 빨래를 하고 설거지를 하고 청소를 한다. 비동기적으로 일을 처리한다면 빨래하는 업체에게 빨래를 시킨다. 설거지 대행 업체에 설거지를 시킨다. 청소 대행 업체에 청소를 시킨다. 셋 중 어떤 것이 먼저 완료될지는 알 수 없다. 일을 모두 마친 업체는 나에게 알려주기로 했으니 나는 다른 작업을 할 수 있다. 이 때는 백그라운드 스레드에서 해당 작업을 처리하는 경우의 비동기를 의미한다.

Sync vs Async
일반적으로 동기와 비동기의 차이는 메소드를 실행시킴과 동시에 반환 값이 기대되는 경우를 동기 라고 표현하고 그렇지 않은 경우에 대해서 비동기 라고 표현한다. 동시에라는 말은 실행되었을 때 값이 반환되기 전까지는 blocking되어 있다는 것을 의미한다. 비동기의 경우, blocking되지 않고 이벤트 큐에 넣거나 백그라운드 스레드에게 해당 task 를 위임하고 바로 다음 코드를 실행하기 때문에 기대되는 값이 바로 반환되지 않는다.

글로만 설명하기가 어려운 것 같아 그림과 함께 설명된 링크를 첨부합니다.

> ## 0207

> ### Array vs LinkedList

- Array

Array(배열) 자료구조는 저장되는 순서에따라 찾고자하는 원소의 index 값으로 해당 원소에 접근을 Big-O(1)로 할 수 있다. 즉 Random Access가 가능하다는 장점이 있는 것이다.

하지만 삭제 또는 추가의 과정에서는 해당 원소에 접근하여 작업하고 난 뒤(O(1)), 추가적으로 작업을 해줘야 하기 때문에, 시간이 더 걸린다. 예를 들면 배열에서 원소를 삭제 했을때, 빈 인덱스가 생기고 전체적으로 연속적인 배여링 되도록 작업을 해줘야한다. 이 경우의 시간 복잡도는 O(n)가 된다. 그렇기 때문에 Array 자료구조에서 삭제 기능에 대한 Time Complexity 의 Worst Case 는 O(n)이 된다.

배열에 추가의 경우도 마찬가지이다. 만약 첫번째 자리에 새로운 원소를 추가하고자 한다면 모든 원소들의 인덱스를 1 씩 shift 해줘야 하므로 이 경우도 O(n)의 시간을 요구하게 된다.

- LinkedList

이러한 배열 자료구조의 문제점을 해결하기 위한 것이 LinkedList 자료구조다. 각 원소들은 자기 자신의 다음 원소만 기억을 한다.(스택, 큐는 연결고리가 있는 것이 아니지만 LinkedList는 원소 간의 연결고리를 엮어주는 것) 따라서 삭제와 추가 작업을 O(1) 만에 해결할 수 있다.

head(시작점) ---- tail(끄트머리)
하지만 LinkedList에도 한 가지 문제가 있다. 원하는 위치에 원소를 삽입을 한다면 원하는 위치를 찾는 과정에서 첫번째 원소부터 모두 확인해야 한다는 것이다. 이 과정 때문에, 어떠한 원소를 삭제 또는 추가하려고 할 때, 그 원소를 찾기 위해서 O(n)의 시간이 추가적으로 발생한다.
