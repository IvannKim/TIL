# 0708
## Data Structures
어떤 구조로 데이터를 만들고 다루는 것이 적합할까?
Stack, Queue, Linked List

### 1) Stack
**Push** - 자료 추가(저장)이 되는 것 (마치 책이 쌓이듯이)
**Pop** - 쌓여있는 순서대로 가장 마지막의 것부터 제거한다.
**Last-in First-out** : 들어간 순서대로 나간다. (LIFO)

#### Big-O
효율성을 간편하게 명시하는 표기법
- Insertion : O(1) -> 1 is constant.
자료를 추가할 때 얼마나 효울적인가?
Q. 같다라고 하는 걸까? 
모든 상황에서 스택에 추가만하는 것이므로 시간이 같다. --> 행동에 있어서 영향이 되는 외부적 조건이 없다(?)같다(?)
- Deletion : **O(1)**
Insertion 처럼 시간이 같다.
- Search : O(n) -> n is Stack-size
찾을때 n의 크기만큼 시간이 (평균적으로) 걸린다.
n이 무엇인지 정확히 정의가 되어야 한다.

#### Real Life Use Cases
실제로 정확히 이해하고 쓸줄 알아야한다.
- Undo / Redo Mechanism
- Backwards / Forwards Mechanism of Browsers
- Call Stack

### 2) Queue
줄 서는 것과 비슷한 방식
**Enqueue** - 자료 추가
**Dequeue** - 자료 제거
**First-in First-out** : 먼저 주문한 사람부터 결제.(FIFO)

#### Big-O
- Insertion : O(1) -> 1 is constant.
줄만 서면 땡. 변수를 고려할 필요 없이 항상 똑같은 오퍼레이션이 동작
- Deletion : **O(1)**
한사람이 빠져나가는 시간만 발생. 별다른 조건이 없다.
- Search : O(n) -> n is Queue-size
Q. 요소 하나를 찾아서 제거한다면? O(n) + O(1)

#### Real Life Use Cases
- Line of people standing for food
- Callback queue : 함수들이 줄 세워 져있는 형식

### 3) Linked List
LinkedList is made of a bunch of nodes that point to the next one in the list
꼬리에 리스트가 연결되어있다고 생각하면 된다. 
스택, 큐는 연결고리가 있는 것이 아니지만 연결리스트는 엘리먼트 간의 연결고리를 엮어주는 것이다. 인지하고있는 것.
하나의 자료에 next(뒤에 있는) 레퍼런스를 기억한다.
head(시작점) ---- tail(끄트머리)
연결리스트와 헷갈리는 것은 배열이다.

자바스크립트와 다른 언어에 따라 배열의 정의가 달라서 다르게 쓰여진다. 스택이나 큐는 언어에 국한되는 것이 아니다. 그래서 스택이나 큐를 배운다. (실제적으로 자바스크립트에서는 배열과 성능이 다르다.)

#### Big-O
- Insertion : O(1) -> 1 is constant.
앞의 꼬리와 연결해주고 뒤를 또 이어준다.
- Deletion : **O(1)**
앞의 꼬리와 뒤를 연결해준다.
- Search : O(n) -> n is Linked List-size
head 부터 검색을 해야만한다.

#### Real Life Use Cases
- The history section of web browsers
- Line of people standing for food

### +)
- Big-O 를 따져봐야한다.

### Tree
#### 개념
- 하나의 루트 노드를 갖는다.
- 루트 노드는 0개 이상의 자식 노드를 갖고 있다.
- 자식 노드 또한 0개 이상의 자식 노드를 갖고 있고 반복적으로 정의된다.

#### 용어
```md
- 루트 노드(root node): 부모가 없는 노드, 트리는 하나의 루트 노드만을 가진다.
- 단말 노드(leaf node): 자식이 없는 노드, ‘말단 노드’ 또는 ‘잎 노드’라고도 부른다.
- 내부(internal) 노드: 단말 노드가 아닌 노드
- 간선(edge): 노드를 연결하는 선 (link, branch 라고도 부름)
- 형제(sibling): 같은 부모를 가지는 노드
- 노드의 크기(size): 자신을 포함한 모든 자손 노드의 개수
- 노드의 깊이(depth): 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수
- 노드의 레벨(level): 트리의 특정 깊이를 가지는 노드의 집합
- 노드의 차수(degree): 하위 트리 개수 / 간선 수 (degree) = 각 노드가 지닌 가지의 수
- 트리의 차수(degree of tree): 트리의 최대 차수
- 트리의 높이(height): 루트 노드에서 가장 깊숙히 있는 노드의 깊이
```
#### 특징
트리는 계층적 모델로 구성되어있다.
루트에서 어떤 노드로 향하는 경로는 유일하다.
루트 노드는 단 1개이며, 모든 자식 노드는 1개의 부모 노드만 가진다. (top-bottom, bottom-top)
사용하는 이유? 계층을 형성하는 정보를 저장할 수 있기 때문이다.

# 0709
### Hashing
데이터를 단시간에 삽입하거나 저장된 데이터를 가져올때 주로 사용한다.
Hash table 자료구조는 배열을 이용한다. key로 배열에 저장된 데이터 요소를 참조 할 수 있다.
#### hash table class
```js
function HashTable() {
	this.table = new Array(137); // 테이블 배열의 크기
	this.simpleHash = simpleHash; // 해쉬 함수
	this.showDistro = showDistro; // 데이터를 보여주는 함수
	this.put = put; // 데이터를 입력시키는 함수
	//this.get == get; // 데이터를 찾는 함수수수수
}
```
#### hash function
key의 데이터형에 따라 해시함수가 달라진다. 
문자열을 해싱하는 경우 문자의 아스키 값을 더하는 함수로 구한 값에 배열의 크기로 나눈 나머지르 해시값으로 반환한다.
```js
function simpleHash(data) {
	let total = 0;
	for (let i = 0; i < data.length; i++) {
		total += data.charCodeAt(i);
	}
	return total % this.table.length;
}
```
해쉬 테이블 데이타 구조에서 중요한 것중 하나가 해쉬 함수(hash function)인데, 좋은 해쉬 함수란, 데이타를 되도록이면 고르게 분포하여, 충돌을 최소화할 수 있는 함수이다.
