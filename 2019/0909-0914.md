# 0909
클래식 ASP
사용자의 정보를 서버에서 조금의 메모리를 보관해둔다. 이것이 세션이다. 그러데 여러 사용자가 동시에 몰리게 된다면 성능적인 면에서 좋지 않아서 대응하려다 망가지게 될것입니다. 서버측의 메모리를 사용해서  저장하는 방식이었습니다. 발전을 하면서 데이터베이스에 상태를 저장하게됩니다. 
세션 서버, 세션 상태 그리고 토큰을 저장합니다. 클라이언트와 서버간의 상호전달이 가능해집니다. 고유한 토큰을 이용해서 사용자의 필요한 데이터를 조회할 수 있습니다. 

이것이 더욱 발전해서 REST의 개념이 탄생한 것이다.
REST는 클라이언트가 서버가 작업을 수행하는데 필요한 모든 것을 서버로 전달한다는 것이다. 그런 다음 서버가 클라이언트로 돌아간다. 이렇게 작업이 완료된다.

# 0910

Roy T. Fielding : "How do I improve HTTP without breaking the Web?"
HTTP 프로토콜을 수정하게 된다면 구축되어있는 Web과 호환성에 문제가 있다. 어떻게 하면 웹을 망가뜨리지 않고 http를 진보시킬 수 있을지 고민했다. 해결책으로 HTTP Object Model 이 탄생했고 얼마 뒤(4년) REST라는 이름으로 발표되었다.

MS 사에서는 SOAP을 만들었다. 
SOAP과 REST를 느낌적으로 비교해보면
S : 복잡하다, 규칙 많음, 어렵다.
R : 단순하다, 규칙 적음, 쉽다. 
결론적으로 REST의 인기가 높아진다.

2008년 CMIS가 발표되면서 EMC, IBM, MS 등이 함께 작업하고 REST도 바인딩 지원했다. 그러나 로이 필딩은 "No REST in CMIS"라고 언급했다. 그저 HTTP API라고 해야된다고 했다.

"REST APIs must be hypertext-driven"
"REST API를 위한 최고의 버저닝 전략은 버저닝을 안하는 것이다."

What's the problem?

rest api : rest 아키텍쳐 스타일을 따르는 api
rest : 분산 하이퍼미디어 시스템(웹)을 위한 아키텍쳐 스타일(제약조건의 집합)

아키텍쳐 스타일에 부합해야 rest를 따른다라고 할 수 있다.

# 0910 - 0912
#### 그렇다면?
1) REST API를 구현하고 REST API라고 부른다.
2) REST API 구현을 포기하고 HTTP API라고 부른다.
3) **REST API가 아니지만 REST API라고 부른다.(요즘)**
3번 을 본 로이필딩은 쫓아와서 "Please try to adhere to them or choose some oother buzzword for your API." (제발 제약조건을 따르던지 아니면 다른 단어를 써라..) 라고 한다.

##### 단점
Q. 일단 왜 API는 REST가 잘 안되나?(일반적인 웹과 비교)
비교 사진
(문제의 원인) 미디어 타입이 흔한 웹페이지들은 HTML이고 HTTP API는 JSON으로 되어있다.

Q. 그런데 Self-descriptive와 HATEOAS가 독립적 진화에 어떻게 도움이 될까요?
- Self-descriptive : 확장 가능한 커뮤니케이션 (서버나 클라이언트가 변경되더라도 오고가는 메세지는 언제나 Self-descriptive 하므로 언제나 (메세지)해석이 가능.)

-HATEOAS : 애플리케이션 상태 전이의 late binding (어디서 어디로 전이가 가능한지 미리 결정되지 않는다. 어떤 상태로 전이가 완료되고 나서야 그 다음 전이될 수 있는 상태가 결정된다. 쉽게 말해서, 링크는 동적으로 변경될 수 있다. // 변경되더라도 변경된 링크로 이돈하면 되기때문이다.)

#### => 그럼 REST API 로 고쳐보자
**JSON**
- Self-descriptive
방법 1) Media type : 미디어 타입 하나 정의, 타입 문서를 작성(id, title 의미 정의), IANA에 미디어 타입을 등록(미디어 타입의 명세로 등록), 메세지를 보는 사람은 명세를 찾아갈 수( 있으므로 메세지의 의미를 온전히 해석할 수 있다.)
단점 : 매번 미디어 타입을 정의 해야한다.
방법 2) Profile : id, title 의미 정의한 명세 작성, link 헤더에 profile relation으로 해당 명세를 링크, 메세지 보는 사람은 명세를 찾아갈 수 있으므로 이 문서의 의미를 온전히 해석할 수 있다.

- HATEOAS
방법 1) data로 : data에 다양한 방법으로 하이퍼링크를 표현한다.
단점 : 링크를 훂현하는 방법을 직접 정의해야한다.
방법 2) HTTP 헤더로 : Link, Location 등의 헤더로 링크를 표현한다.
단점 : 정의된 relation만 활용한다면 표현에 한계가 있다.

## +)
- 오늘날 대부분의 "REST API"는 사실 REST를 따르지 않고 있다.
- REST의 제약조건 중에서 특히 **Self-descriptive**와 **HATEOAS**를 잘 만족하지 못한다.
- REST는 **긴 시간에 걸쳐(수십년) 진화**하는 웹 어플리케이션을 위한 것이다.
- REST를 따를 것인지는 API를 설계하는 이들이 스스로 판단해서 결정해야한다.
- REST를 따른다면,  **Self-descriptive**와 **HATEOAS**를 만족시켜야한다.
	- Self-descriptive는 **custom media type**이나 **profile link relation**등으로 만족시킬 수 있다.
	- HATEOAS는 HTTP 헤더나 본문에 링크를 담아 만족시킬 수 있다.
- REST를 따르지 않겠다면, "REST를 만족하지 않는 REST API"를 뭐라고 부를지 결정해야할 것이다.
	- HTTP API라고 할수도 있고
	- 그냥 이대로 REST API라고 할 수 있다.(로이가 싫어할 것이다..)

## 결론
- 오늘날 대부분의 "REST API"는 사실 REST를 따르지 않고 있다.
- REST의 제약조건 중에서 특히 **Self-descriptive**와 **HATEOAS**를 잘 만족하지 못한다.
- REST는 **긴 시간에 걸쳐(수십년) 진화**하는 웹 어플리케이션을 위한 것이다.
- REST를 따를 것인지는 API를 설계하는 이들이 스스로 판단해서 결정해야한다.
- REST를 따른다면,  **Self-descriptive**와 **HATEOAS**를 만족시켜야한다.
	- Self-descriptive는 **custom media type**이나 **profile link relation**등으로 만족시킬 수 있다.
	- HATEOAS는 HTTP 헤더나 본문에 링크를 담아 만족시킬 수 있다.
- REST를 따르지 않겠다면, "REST를 만족하지 않는 REST API"를 뭐라고 부를지 결정해야할 것이다.
	- HTTP API라고 할수도 있고
	- 그냥 이대로 REST API라고 할 수 있다.(로이가 싫어할 것이다..)

RESTful API를 구현하는 근본적인 목적이 퍼포먼스 향상에 있는게 아니라, 일관적인 컨벤션을 통한 API의 이해도 및 호환성을 높이는게 주 동기이니, 퍼포먼스가 중요한 상황에서는 굳이 RESTful API를 구현하실 필요는 없습니다.

REST는 여러 가지 서비스 디자인에서 생길 수 있는 문제를 최소화해주고, HTTP 프로토콜의 표준을 최대한 활용하여 여러 추가적인 장점을 함께 가져갈 수 있게 해줍니다.

마지막으로 REST API는 정해진 명확한 표준이 없기 때문에 REST API를 사용함에 있어 '무엇이 옳고 그른지'가 아닌 개발하는 서비스의 특징과 개발 집단의 환경과 성향 등이 충분히 고려되어 설계되어야 할 것입니다.
하지만 그럼에도 REST가 중요한 점은, 이를 제대로 구현하는 것이 서비스 디자인에 큰 부가이익을 가져다 줄 수 있으며, 많은 현대의 API들이 REST를 어느 정도로 충실하게 반영하느냐를 고민할 뿐이지 REST를 중심으로 디자인되고 있다는 점은 분명하기 때문입니다. REST를 얼마나 반영할 지는 API가 어떤 개발자를 범위에 두는지, 개발 기간이 얼마나 되는지, 함께 하는 동료의 역량은 어떠한지 등을 고려해서 집단마다 다르게 반영하게 될 것입니다.

‘REST가 완전한 정답이냐?’ 그렇다면 대안은?
일반적으로 GraphQL을 쓴다.