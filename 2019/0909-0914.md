# 0909
클래식 ASP
사용자의 정보를 서버에서 조금의 메모리를 보관해둔다. 이것이 세션이다. 그러데 여러 사용자가 동시에 몰리게 된다면 성능적인 면에서 좋지 않아서 대응하려다 망가지게 될것입니다. 서버측의 메모리를 사용해서  저장하는 방식이었습니다. 발전을 하면서 데이터베이스에 상태를 저장하게됩니다. 
세션 서버, 세션 상태 그리고 토큰을 저장합니다. 클라이언트와 서버간의 상호전달이 가능해집니다. 고유한 토큰을 이용해서 사용자의 필요한 데이터를 조회할 수 있습니다. 

이것이 더욱 발전해서 REST의 개념이 탄생한 것이다.
REST는 클라이언트가 서버가 작업을 수행하는데 필요한 모든 것을 서버로 전달한다는 것이다. 그런 다음 서버가 클라이언트로 돌아간다. 이렇게 작업이 완료된다.

# 0910

Roy T. Fielding : "How do I improve HTTP without breaking the Web?"
HTTP 프로토콜을 수정하게 된다면 구축되어있는 Web과 호환성에 문제가 있다. 어떻게 하면 웹을 망가뜨리지 않고 http를 진보시킬 수 있을지 고민했다. 해결책으로 HTTP Object Model 이 탄생했고 얼마 뒤(4년) REST라는 이름으로 발표되었다.

MS 사에서는 SOAP을 만들었다. 
SOAP과 REST를 느낌적으로 비교해보면
S : 복잡하다, 규칙 많음, 어렵다.
R : 단순하다, 규칙 적음, 쉽다. 
결론적으로 REST의 인기가 높아진다.

2008년 CMIS가 발표되면서 EMC, IBM, MS 등이 함께 작업하고 REST도 바인딩 지원했다. 그러나 로이 필딩은 "No REST in CMIS"라고 언급했다. 그저 HTTP API라고 해야된다고 했다.

"REST APIs must be hypertext-driven"
"REST API를 위한 최고의 버저닝 전략은 버저닝을 안하는 것이다."

What's the problem?

rest api : rest 아키텍쳐 스타일을 따르는 api
rest : 분산 하이퍼미디어 시스템(웹)을 위한 아키텍쳐 스타일(제약조건의 집합)

아키텍쳐 스타일에 부합해야 rest를 따른다라고 할 수 있다.

# 0910 - 0912
#### 그렇다면?
1) REST API를 구현하고 REST API라고 부른다.
2) REST API 구현을 포기하고 HTTP API라고 부른다.
3) **REST API가 아니지만 REST API라고 부른다.(요즘)**
3번 을 본 로이필딩은 쫓아와서 "Please try to adhere to them or choose some oother buzzword for your API." (제발 제약조건을 따르던지 아니면 다른 단어를 써라..) 라고 한다.

##### 단점
Q. 일단 왜 API는 REST가 잘 안되나?(일반적인 웹과 비교)
비교 사진
(문제의 원인) 미디어 타입이 흔한 웹페이지들은 HTML이고 HTTP API는 JSON으로 되어있다.

Q. 그런데 Self-descriptive와 HATEOAS가 독립적 진화에 어떻게 도움이 될까요?
- Self-descriptive : 확장 가능한 커뮤니케이션 (서버나 클라이언트가 변경되더라도 오고가는 메세지는 언제나 Self-descriptive 하므로 언제나 (메세지)해석이 가능.)

-HATEOAS : 애플리케이션 상태 전이의 late binding (어디서 어디로 전이가 가능한지 미리 결정되지 않는다. 어떤 상태로 전이가 완료되고 나서야 그 다음 전이될 수 있는 상태가 결정된다. 쉽게 말해서, 링크는 동적으로 변경될 수 있다. // 변경되더라도 변경된 링크로 이돈하면 되기때문이다.)

#### => 그럼 REST API 로 고쳐보자
**JSON**
- Self-descriptive
방법 1) Media type : 미디어 타입 하나 정의, 타입 문서를 작성(id, title 의미 정의), IANA에 미디어 타입을 등록(미디어 타입의 명세로 등록), 메세지를 보는 사람은 명세를 찾아갈 수( 있으므로 메세지의 의미를 온전히 해석할 수 있다.)
단점 : 매번 미디어 타입을 정의 해야한다.
방법 2) Profile : id, title 의미 정의한 명세 작성, link 헤더에 profile relation으로 해당 명세를 링크, 메세지 보는 사람은 명세를 찾아갈 수 있으므로 이 문서의 의미를 온전히 해석할 수 있다.

- HATEOAS
방법 1) data로 : data에 다양한 방법으로 하이퍼링크를 표현한다.
단점 : 링크를 훂현하는 방법을 직접 정의해야한다.
방법 2) HTTP 헤더로 : Link, Location 등의 헤더로 링크를 표현한다.
단점 : 정의된 relation만 활용한다면 표현에 한계가 있다.

## +)
- 오늘날 대부분의 "REST API"는 사실 REST를 따르지 않고 있다.
- REST의 제약조건 중에서 특히 **Self-descriptive**와 **HATEOAS**를 잘 만족하지 못한다.
- REST는 **긴 시간에 걸쳐(수십년) 진화**하는 웹 어플리케이션을 위한 것이다.
- REST를 따를 것인지는 API를 설계하는 이들이 스스로 판단해서 결정해야한다.
- REST를 따른다면,  **Self-descriptive**와 **HATEOAS**를 만족시켜야한다.
	- Self-descriptive는 **custom media type**이나 **profile link relation**등으로 만족시킬 수 있다.
	- HATEOAS는 HTTP 헤더나 본문에 링크를 담아 만족시킬 수 있다.
- REST를 따르지 않겠다면, "REST를 만족하지 않는 REST API"를 뭐라고 부를지 결정해야할 것이다.
	- HTTP API라고 할수도 있고
	- 그냥 이대로 REST API라고 할 수 있다.(로이가 싫어할 것이다..)

## 결론
- 오늘날 대부분의 "REST API"는 사실 REST를 따르지 않고 있다.
- REST의 제약조건 중에서 특히 **Self-descriptive**와 **HATEOAS**를 잘 만족하지 못한다.
- REST는 **긴 시간에 걸쳐(수십년) 진화**하는 웹 어플리케이션을 위한 것이다.
- REST를 따를 것인지는 API를 설계하는 이들이 스스로 판단해서 결정해야한다.
- REST를 따른다면,  **Self-descriptive**와 **HATEOAS**를 만족시켜야한다.
	- Self-descriptive는 **custom media type**이나 **profile link relation**등으로 만족시킬 수 있다.
	- HATEOAS는 HTTP 헤더나 본문에 링크를 담아 만족시킬 수 있다.
- REST를 따르지 않겠다면, "REST를 만족하지 않는 REST API"를 뭐라고 부를지 결정해야할 것이다.
	- HTTP API라고 할수도 있고
	- 그냥 이대로 REST API라고 할 수 있다.(로이가 싫어할 것이다..)

RESTful API를 구현하는 근본적인 목적이 퍼포먼스 향상에 있는게 아니라, 일관적인 컨벤션을 통한 API의 이해도 및 호환성을 높이는게 주 동기이니, 퍼포먼스가 중요한 상황에서는 굳이 RESTful API를 구현하실 필요는 없습니다.

REST는 여러 가지 서비스 디자인에서 생길 수 있는 문제를 최소화해주고, HTTP 프로토콜의 표준을 최대한 활용하여 여러 추가적인 장점을 함께 가져갈 수 있게 해줍니다.

마지막으로 REST API는 정해진 명확한 표준이 없기 때문에 REST API를 사용함에 있어 '무엇이 옳고 그른지'가 아닌 개발하는 서비스의 특징과 개발 집단의 환경과 성향 등이 충분히 고려되어 설계되어야 할 것입니다.
하지만 그럼에도 REST가 중요한 점은, 이를 제대로 구현하는 것이 서비스 디자인에 큰 부가이익을 가져다 줄 수 있으며, 많은 현대의 API들이 REST를 어느 정도로 충실하게 반영하느냐를 고민할 뿐이지 REST를 중심으로 디자인되고 있다는 점은 분명하기 때문입니다. REST를 얼마나 반영할 지는 API가 어떤 개발자를 범위에 두는지, 개발 기간이 얼마나 되는지, 함께 하는 동료의 역량은 어떠한지 등을 고려해서 집단마다 다르게 반영하게 될 것입니다.

‘REST가 완전한 정답이냐?’ 그렇다면 대안은?
일반적으로 GraphQL을 쓴다.

# 0913
# Schema Design
## 1) SQL vs NoSQL
SQL과 NoSQL의 차이와 각각의 장단점에 대해 설명해주세요.
https://www.thorntech.com/wp-content/uploads/2019/03/SQL-vs-NoSQL-blog-image.jpg

### 개요
지난주 과제를 하면서 MongoDB를 사용했었다. 백엔드에 관해 조금 더 알아보던 중 ORM, ODM도 찾아보면서 몽고디비는  NoSQL이라는 것을 알게됐다. 그렇다면 SQL도 있을터인데, 바로 MySQL과 같은것들이다.
웹 프로젝트를 개발하면서 두가지 사항 중에 선택하게 되는 것 같다.
일단 나는 노드제이에스와 함께 몽고디비를 사용해봤기때문에 몽고디비가 더 좋아보이는 것은 사실이었다.

더욱 현실적으로는 거의 두가지 모두 모르는 것이나 마찬가지이다. 그래서 이번 발표자료를 준비하면서 조금이나마 개념을 알게됐고 차이점을 알게됐습니다.

### SQL
SQL은 '구조화 된 쿼리 언어 (Structured Query Language)'의 약자입니다. 그러므로 데이터베이스 자체를 나타내는 것이 아니라, 특정 유형의 데이터베이스와 상호 작용하는 데 사용 하는 쿼리 언어입니다. 
SQL을 '관계형 데이터베이스' 라는 의미로도 사용합니다.
SQL을 사용하면 관계형 데이터베이스 관리 시스템(RDBMS)에서 데이터를 저장, 수정, 삭제 및 검색 할 수 있습니다.
이러한 관계형 데이터베이스에는 두 가지 주요 특징이 있습니다.  
데이터는 **정해진(엄격한) 데이터 스키마 (= structure)를 따라** 데이터베이스 테이블에 저장됩니다.
데이터는 관계를 통해서 연결된 **여러개의 테이블에 분산**됩니다.

1) 엄격한 스키마
데이터는 테이블(table)에 레코드(record)로 저장되며, 각 테이블에는 명확하게 정의된 구조(structure)가 있습니다. (구조란 어떤 데이터가 테이블에 들어가고 어떤 데이터가 그렇지 않을지를 정의하는 필드(field) 집합을 가르킵니다.)
구조(structure)는 필드의 이름과 데이터 유형으로 정의됩니다.
(관계형 데이터베이스에서) 스키마를 준수하지 않는 레코드는 추가할 수 없습니다. 더 많은 필드를 얻고 싶다구요? 죄송합니다만 다른 테이블을 선택하셔야 합니다. 일부 필드가 누락 되었다구요? 아무튼 이 테이블은 안돼요! (예를 들어, 위 테이블에서 '유통 기한'이라는 필드를 넣고 싶다면, 스키마를 뜯어고치지 않는한 필드를 추가 할 수 없다는 겁니다.)
2) 관계
SQL 기반의 데이터 베이스의 또 다른 중요한 부분은 관계입니다.
데이터들을 여러개의 테이블에 나누어서, 데이터들의 중복을 피할 수 있습니다. 만약 사용자가 구입한 상품들을 나타내기 위해서는, Users(사용자), Products(상품), Orders(주문한 상품) 여러 테이블을 만들어야 하지만, 각각의 테이블들은 다른 테이블에 저장되지 않은 데이터 만을 가지고 있습니다. (중복된 데이터가 없습니다.) 
이런 명확한 구조는 장점이 있습니다. 하나의 테이블에서 중복없이 하나의 데이터만을 관리하기 때문에, 다른 테이블에서 부정확한 데이터를 다룰 위험이 없습니다.

오픈 소스였던 MySQL이 오라클로 넘어가게 되면서 오픈이 되지않고 그 대안으로 내부 직원이 퇴사를 하고 새롭게 오픈소스로 만들기 시작한 SQL DB 서비스가 있다. => 

#### 장점
명확하게 정의 된 스키마, 데이터 무결성 보장
관계는 각 데이터를 중복없이 한번만 저장됩니다.

#### 단점
상대적으로 덜 유연합니다. 데이터 스키마는 사전에 계획되고 알려져야 합니다. (나중에 수정하기가 번거롭거나 불가능 할 수 도 있습니다.)
관계를 맺고 있기 때문에, JOIN문이 많은 매우 복잡한 쿼리가 만들어 질 수 있습니다.
수평적 확장이 어렵고, 대체로 수직적 확장만 가능합니다. 즉 어떤 시점에서 (처리 할 수 있는 처리량과 관련하여) 성장 한계에 직면하게 됩니다.