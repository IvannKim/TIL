# 0805
(테스트 이후 일주일 쉬고(?)나서 첫 수업이다. 솔직하게 스스로의 상태를 적어보자면 수련회 사역을 하는 동안 4일을 제대로 공부하지 못해서 오늘 많이 낯설다. 하지만 이미 지난 일이니까 오늘부터 최선을 다해 살아봅시다!)

### +)
- 버추얼 돔

## React
브라우저로 실행되면 JSX가 HTML로 변환된다.
리턴 값 내의 JSX를 작성하면서 `{}`를 활용하면 JS 읷프프레션을 쓸 수 있다.

돔을 컴포넌트에 적용하고 싶을때 리액트 돔을 쓴다. 적용하고 싶은 곳도 지정할 수 있다. 
`ReactDOM.render(<Game />)`

리액트에서는 가상돔을 활용. 돔을 관리하는 것. 직접관리한다기 보다 리액트의 업무에 맡기는 것. 
리액트가 인식하는 문법들을 익혀야 한다. ex) `<div className="kamake">`
태그를 만드는 것은 실제로 변환이 될때 크레이트 엘레멘트를 적용 (클래스를 준다. 즉, 클래스 네임의 **정보를 전달**한다는 것)
돔에 적용가능항 기능을 비슷한 방법으로 리액트에서 적용할 수 있다.

정의(설계)된 컴포넌트를 이용할때, 컴포넌트를 사용 할때 값을 추가하게 되면 추가정보를 정의된 클래스에서 props로 값들을 받을 수 있다.
-> 외부에서 오는 매개변수를 활용하는 함수와 비슷하다.

컴포넌트 내에서 또 다른 컴포넌트를 사용 할때는 부모관계(트리구조)가 된다.
하위 컴포넌트들을 자식으로 정의해주는 형태로 진행하게 된다.

리액트의 문법상 내용은 브라우저상에서 확인하기 힘들다.

**이벤트가 필요할때, 태그 내에서 카멜케이스로 작성해야하고 함수실행문이 아니라 함수를 입력해야한다.**
ex) `<div onClick={() => console.log(123)} >{status}</div>`
함수실행문을 입력한다면, 랜더 메소드가 실행될때 엘리먼트를 생성. 함수실행문의 실행되는 기점은 랜더함수가 실행될때 동시에 동작한다. 함수의 활용이 사용자의 행동에 따라 활용하려면 함수명만 입력해주면 된다.

nativeEvent : 실제 이벤트 객체 
가상 돔의 이벤트 객체를 여기저기 재사용한다. 액트가 실행되고 난 후 사용하지 않을때  null을 할당하면서 비워준다.

필요한 정보가 있다면 실행 되기 전에 미리 (따놓는)작업을 해놔야한다. ( 특히 비동기 작업을 해야할때)


클래스 내부에 컨스트럭터를 입력하고 내부에 슈퍼()입력
```js
class Kamake extends Component {
	constructor(props) {
		super(props);
		//내부적으로 관리하는 정보를 가지도록.
		this.state = { //this는 인스턴스로 관리(각자 따로 관리)
			isClicked: false
		};
	}
}
```
상태를 변경해야할때
state에 직접적으로 변경할 수 없고 내부적으로 설정된 `setState`를 활용하면 된다.
```js
this.setState({
	isClicked: true
})
```
새로운 정보를 통채로 할당시켜줘야한다.
이벤트를 작동해서 state에 변화를 준다면 랜더가 또다시 새롭게 실행된다. rerender
부모가 리랜더 된다면 자식도 새롭게 랜더된다.

이벤트핸들러를 호출할때는 언스트릭트모드에서 실행되기때문에 this를 언디파인드가 된다.
그래서 랜더하면서 함수에 바인드를 해줘야 this값을 연장해서 참조할 수 있다.

state를 만들때 중요한 것은 어느 단계에서 유용하게 관리할수 있는지 고민하는 것이 좋다.
매개변수(prop)로 받아오는 정보라면 스테이트로 관리해줄 필요 없다.

자식의 동작으로 인해서 부모에게 정보를 알려줘야한다면 부모단계에서 상탤르 알수있는 함수를 prop으로 주면된다.

참조형 자료는 값을 복사해서 사용해야한다.

prop과 state 를 고민
setState는 반드시 카피해서
신테틱 이벤트
데이터 흐름을 파악하고 익숙

컴포넌트 구분 권장사항은 너무 잘게 쪼개지 말고 큼직하게 하기
처음부터 작게 시작한다기 보다 크게 시작
하나의 컴포넌트로 관리하기 벅차다면 쪼개면서

lifecycle 꼭!!