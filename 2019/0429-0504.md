# 0429

- 프로토타입

: 자바스크립트는 프로그래밍 언어의 기존 C++이나 자바와 같은 객체지향 프로그래밍 언어와는 다른 **프로토타입 기반의 객체지향 프로그래밍**을 지원한다. 따라서 JS의 동작 과정을 제대로 이해하려면 프로토 타입의 개념도 잘 이해해야한다. 

 자바와 같은 객체지향 프로그래밍에서는 클래스를 정의하고 이를 통해 객체를 생성하지만, JS에서는 이러한 클래스 개념이 없다. 대신 객체 리터럴이나 생성자 함수로 객체를 생성할 수 있다. 이렇게 생성된 객체의 부모객체가 ***프로토타입*** 객체다. 상속개념과 마찬가지로 자식 객체는 부모객체가 가진 프로퍼티 접근이나 메서드를 상속받아 호출하는 것이 가능하다. 

 JS에서 모든 객체는 자신을 생성한 생성자 함수의 **prototype 프로퍼티**가가리키는 **프로토타입객체**를 자신의 부모 객체로 설정하는 **[[Prototype]] 링크**로 연결 한다.

 결국, 객체를 생성하는 것은 생성자 함수의 역할이지만, 생성된 객체의 실제 부모역할을 하는 것은 생성자 자신이 아닌 prototype 프로퍼티가 가리키는 프로토타입 객체다.

# 0430

## Object
```js
var obj = {
	name: 'kamake'
};
```
객체 내의 value(값)에는 자바스크립트에 존재하는 어떤 것이 들어와도 가능하다.
키값은 문자열로도 표기 가능하다. 왜냐면 결국 내부적으로 string으로 입력되기 때문이다.  자바스크립트에서 객체 내부적으로는 key값을 String으로 변환해서 인식하고 처리한다. 그렇기 때문에 그 키값을 필요에 의해 찾는 다면, 이해하고 찾아야 한다.

<B>객체의 키(속성, 프로퍼티), 벨유를 반복문을 하고싶다면 </B>

- for... in
  : 객체의 키값에는 순서가 정해져 있다고 장담할 수 없다. 임의대로 반복을 한다.

```js
var a = {
	name: 'kamake',
	age: 28
};

for(var prop in a) {
 console.log(prop);  // key 값을 가져올 수 있음음음음
 console.log(a[prop]); //value 값도 가져올 수 있음
}
```
```js
var kamake = 123;
var a = 'firstName';

var obj = {
	a: kamake; // 'firstName': 123
};

console.log(obj[''+'a'+''+'']) // 123 (결국 []에 남는 값이 키값과 같으면 된다.)
```

###+)
- 구조를 예쁘게 잘 짜는 것이 능력이다. => 자료구조 공부



## Array
 배열은 객체의 하위호환이라 생각하면 된다. 배열도 객체이기 때문에 어떤 타입의 값이 지정되어도 상관 없다.

- `unshift( )`, `pop( )` 는 배열의 앞, 뒤의 요소를 제거하고, 제거된 요소를 반환한다. 단, 빈 배열일 경우 `undefined`를 반환한다.
- `shift(z)`, `push(z)` 는 배열의 가장 앞, 뒤에 새로운 요소 `z`를 추가하고, 배열의 새로운 길이를 반환한다.



###+)
- JS에서 배열은 객체지만 순서가 있다. (index)
- 객체와 같이 요소는 무엇이든지 가능
- 문자열은 이미 저장된 상태이므로 할당된 값 자체를 직접 변경시킬 수 없다. (값을 활용해서 분해시켜서 중간중간 요소나 전체 정보를 변경시킬 수 있다.)
- 메소드를 공부 할때 중요한 것은 **디테일하게** 무엇이 매개변수가 되고 반환되는지 알아야 한다. 기본적인 "설명"부터 읽고 이해해야 한다. "기본예제"를 파악해야한다. "구문"항목도 기억해야한다. 




## Primitive vs Reference
모든 값은 그 성격에 따라 구분 할 수 있다.
### 1) Primitive(원시적인)
#### - Type
- Boolean
- Number
- String
- Null
- Undefined
```shell
Q. 할당되어 있지 않는 값을 찾게 되면 null이 아니라 undefined로 표현되는 것일까?
(값이 없는 것이라면 undefined가 아닌 아무 값조차 없는 null이 어울리지 않을까?)
A. undefined 라고 표현하기로 약속된 것이기 때문이다. 
```
변수에 Primitive 값을 할당하고 값을 비교할때, 같은 값이면 같다라고 치부하는 것이다. 
변수에 이미 할당된 값을 새로운 값으로 할당 한다면 전에 존재했던 값은 재활용하지 못한다. ( 값에 할당된 메모리 주소를 재활용하지 않고 새롭게 메모리 주소를 링크해서 그 값을 변수에 할당 해준다. )


### 2) Reference

 값의 생김새(타입, 값)가 같아 보여도 참조하고 있는 위치가 다르다면 같은 값이라 보기 어렵다. JS는 **객체를 *생성하면* 새로운 장소에 저장**한다. 위치는 항상 다를 수 박에 없는 성질이 있다. 특수한 객체인 배열과 함수 모두 객체에 포함되기 때문에 저장된 위치를 꼼꼼히 신경 써야 한다. 

- 변수에 참조된 주소는 같지만 할당된 정보는 다르다.
- 위치를 기준으로 비교를 하게 된다. 
- 변수에 할당할 객체를 새롭게 생성한다면 객체의 위치를 변수에 저장 시켜놓는다.

객체를 비교해서 위치를 신경써야하는 것이 아니라 변수를 비교할 때는 어디에 담겨있는지와는 상관없이 그 변수만을 판단하면 된다.



## +)

- 내가 사용할 수 있는 재료들에 대해 공부하는 것.  얼마나 잘 조합할 수 있는지, 마치 전쟁터에서 군인들을 적재적소에 배치해서 뛰어난 용병술을 가지는 것이 중요하다.
- 개념들을 알고 지나가는 것이 아니라 **직접 사용해보면서 인지하고 기억하기!** 
- 꼼꼼히 읽으면서 공부 & 작업하기
- 문서(article)에서 영단어를 만나면 의미를 먼저 파악해라.

# 0501

- 함수의 기본 메소드인 `call()`, `apply()`는 함수 호출할 때, `bind()`는 함수를 선언하는 단계일 때 쓴다.