# 0805
(테스트 이후 일주일 쉬고(?)나서 첫 수업이다. 솔직하게 스스로의 상태를 적어보자면 수련회 사역을 하는 동안 4일을 제대로 공부하지 못해서 오늘 많이 낯설다. 하지만 이미 지난 일이니까 오늘부터 최선을 다해 살아봅시다!)

### +)
- 버추얼 돔

## React
브라우저로 실행되면 JSX가 HTML로 변환된다.
리턴 값 내의 JSX를 작성하면서 `{}`를 활용하면 JS 읷프프레션을 쓸 수 있다.

돔을 컴포넌트에 적용하고 싶을때 리액트 돔을 쓴다. 적용하고 싶은 곳도 지정할 수 있다. 
`ReactDOM.render(<Game />)`

리액트에서는 가상돔을 활용. 돔을 관리하는 것. 직접관리한다기 보다 리액트의 업무에 맡기는 것. 
리액트가 인식하는 문법들을 익혀야 한다. ex) `<div className="kamake">`
태그를 만드는 것은 실제로 변환이 될때 크레이트 엘레멘트를 적용 (클래스를 준다. 즉, 클래스 네임의 **정보를 전달**한다는 것)
돔에 적용가능항 기능을 비슷한 방법으로 리액트에서 적용할 수 있다.

정의(설계)된 컴포넌트를 이용할때, 컴포넌트를 사용 할때 값을 추가하게 되면 추가정보를 정의된 클래스에서 props로 값들을 받을 수 있다.
-> 외부에서 오는 매개변수를 활용하는 함수와 비슷하다.

컴포넌트 내에서 또 다른 컴포넌트를 사용 할때는 부모관계(트리구조)가 된다.
하위 컴포넌트들을 자식으로 정의해주는 형태로 진행하게 된다.

리액트의 문법상 내용은 브라우저상에서 확인하기 힘들다.

**이벤트가 필요할때, 태그 내에서 카멜케이스로 작성해야하고 함수실행문이 아니라 함수를 입력해야한다.**
ex) `<div onClick={() => console.log(123)} >{status}</div>`
함수실행문을 입력한다면, 랜더 메소드가 실행될때 엘리먼트를 생성. 함수실행문의 실행되는 기점은 랜더함수가 실행될때 동시에 동작한다. 함수의 활용이 사용자의 행동에 따라 활용하려면 함수명만 입력해주면 된다.

nativeEvent : 실제 이벤트 객체 
가상 돔의 이벤트 객체를 여기저기 재사용한다. 액트가 실행되고 난 후 사용하지 않을때  null을 할당하면서 비워준다.

필요한 정보가 있다면 실행 되기 전에 미리 (따놓는)작업을 해놔야한다. ( 특히 비동기 작업을 해야할때)


클래스 내부에 컨스트럭터를 입력하고 내부에 슈퍼()입력
```js
class Kamake extends Component {
	constructor(props) {
		super(props);
		//내부적으로 관리하는 정보를 가지도록.
		this.state = { //this는 인스턴스로 관리(각자 따로 관리)
			isClicked: false
		};
	}
}
```
상태를 변경해야할때
state에 직접적으로 변경할 수 없고 내부적으로 설정된 `setState`를 활용하면 된다.
```js
this.setState({
	isClicked: true
})
```
새로운 정보를 통채로 할당시켜줘야한다.
이벤트를 작동해서 state에 변화를 준다면 랜더가 또다시 새롭게 실행된다. rerender
부모가 리랜더 된다면 자식도 새롭게 랜더된다.

이벤트핸들러를 호출할때는 언스트릭트모드에서 실행되기때문에 this를 언디파인드가 된다.
그래서 랜더하면서 함수에 바인드를 해줘야 this값을 연장해서 참조할 수 있다.

state를 만들때 중요한 것은 어느 단계에서 유용하게 관리할수 있는지 고민하는 것이 좋다.
매개변수(prop)로 받아오는 정보라면 스테이트로 관리해줄 필요 없다.

자식의 동작으로 인해서 부모에게 정보를 알려줘야한다면 부모단계에서 상탤르 알수있는 함수를 prop으로 주면된다.

참조형 자료는 값을 복사해서 사용해야한다.

prop과 state 를 고민
setState는 반드시 카피해서
신테틱 이벤트
데이터 흐름을 파악하고 익숙

컴포넌트 구분 권장사항은 너무 잘게 쪼개지 말고 큼직하게 하기
처음부터 작게 시작한다기 보다 크게 시작
하나의 컴포넌트로 관리하기 벅차다면 쪼개면서

lifecycle 꼭보기!!

# 0806
### +)
- axios를 이용해서 AJAX요청을 해봤다. 다행히 API로 받아온 data를 활용해서 조금씩 무언가를 만들기 시작했다.
- 처음으로 제대로 리액트를 배우고 이것저것 조금씩 건드려봤는데, JS를 조금 알아서 낯선것은 아니었다 하지만 리액트의 가상 돔과 컴포넌트기반의 사용법이 익숙치가 않다.

# 0807
리액트는 false, null, undefined를 화면에 보여주지 않는다. 
JSX 를 작성할때 `{}`를 사용해서 익스프레션 내에서 태그나 만들어져 있는 컴포넌트를  활용할 수 있다.
결과값이 나오는 표현식을 입력할 수 있다.
배열의 요소가 리액트 엘리먼트인지 판별하고 화면에 입력한다.
리턴문 내에 하나의 태그로 하나의 리액트 엘리먼트로서 하나의 값이 나와야한다. 그래서 하나로 감싸는 태그가 필요하다.
감싸는 태그를 `Fragment`나 `<></>`를 사용하면 브라우저 개발자 도구 상에서는 감싸는 태그가 보이지 않는다. 사용하는 이유는 굳이 헷갈릴 필요없는 태그에 신경쓰지 않아도 되는 것이다.

### consructor
내에서 state, props외에 다른 인스턴스를 입력해도 된다. 하지만 합당한 이유가 있어야 할것이다.

## +)
어쩔수 없이 돔 엘리먼트를 잡아야 할때가 있다.
레퍼런스를 이용해서 활용해야할 수가 있다. 
작업을 하다 보면 보편적인 상황을 벗어날때가 있다. 
https://ko.reactjs.org/docs/refs-and-the-dom.html
비디오를 실행할때는 ref를 잡아야한다. 등등
**But Don't overuse ref**

클래스를 활용해서 컴포넌트를 생성할 수 있지만 함수로도 생성할 수 있다.
함수형 , 스테이틀리스(과거), 리액트 훅스로 인해 쓸 수 있음.
https://velog.io/@velopert/react-hooks

컴포넌트를 사용할때 셀프 클로징 태그가 아니라 열고 닫는 태그를 사용할때 사이에 리액트엘리먼트(태그)를 끼워 넣으면 리액트가 자동으로 props.children의 prop으로 전달된다. (셀프클로징에서도 `children={}`내에 넣으면 같은 상황이다.)
https://reactjs-kr.firebaseapp.com/docs/jsx-in-depth.html#jsx%EC%97%90%EC%84%9C-%EC%9E%90%EC%8B%9D%EB%8B%A4%EB%A3%A8%EA%B8%B0

## Life Cycle
https://reactjs-kr.firebaseapp.com/docs/state-and-lifecycle.html
- constructor
- render
- **componentDidMount** : 마운트가 끝남
- componentDidUpdate : 업데이트가 끝남
- componentWillUnmount : 언마운트 될때

컴포넌트에서 사용할때 메소드명을 정확히 일치하게 입력해야한다. 컴포넌트 하나당 메소드들이 호출되는 순서를 기억한다. 
#### shouldComponentUpdate
`return`을 `Boolean` 값으로 꼭 해줘야 하고 `true`가 반환되면 `render`하면서 업데이트 시킨다.(componentDidUpdate)  `false`가 반환되면 `render`하지 않으면서 업데이트 하지 않는다.(componentWillUnmount)
반환 값이 `true`여서 `render`가 되면 내부에 속해 있던 자식 컴포넌트도 업데이트되는 것이기 때문에 shouldComponentUpdate가 자식 컴포넌트 내에서도 호출되면서 componentDidUpdate, componentWillUnmount로 또 나뉠것이다.

`setState()`로 인해 기존 state가 변경되면서 확인한다. 다시 말해 새롭게 반영되기전에 사용자가 입력해놓은 코드에 응답을 구하기 때문에 기존 값과 새로 변경될 값도 알고 있다.

#### render
Pure function 여야 한다. 마운트가 된 상태가 아니기 때문에 브라우저의 돔을 직접적으로 건드리는 작업은 하면 안된다.

#### componentDidMount
DOM 트리에 마운트 되자마자 즉시 실행된다. 가능하면 state를 직접변경하지 않는 것이 좋다.(사용자가 느끼진 못하지만 성능적으로 좋지 않다.)
그러나 예외적으로 비동기적인 작업을 할때는 state를 변경시켜도 된다.